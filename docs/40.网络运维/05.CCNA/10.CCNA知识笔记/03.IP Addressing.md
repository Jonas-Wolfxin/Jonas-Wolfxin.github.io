---
title: IP Addressing
date: 2023-03-31 03:34:29
permalink: /pages/68df0c/
categories:
  - 网络运维
  - CCNA
  - CCNA知识笔记
tags:
  - 
---


# IP Addressing

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325549.png" alt="image-20220623091803068" style="zoom:60%;" />



## IPv4 Addressing

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325646.png" alt="image-20220623095637294" style="zoom:80%;" />

- IPv4 address 表示为 **binary notation**时的长度为 32bits（4个Byte, 或者 Octet）, 由于便于可读性, 一般表示为 **dotted decimal notation**。IPv4地址由**Network portion**和**Host Portion**组成，这取决于子网掩码(**netmasks** or **prefix length**)，可定义各种地址类：A、B、C、D 或 E。

- IPv4 地址的总数为 4 294 967 296, 即 2^32^ = 42.9亿 = 4.3 * 10^9^. 



### IPv4 Classes

> ![preview](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325018.jpeg)
>
> 
>
> - **A类 IP/8**(*A类IP地址的首个二进制位必须是0开头: 1~126*):
>
>     - 起始: (**0**000 0001).0.0.1   --> 十进制: `1.0.0.1/8`
>
>     - 终止: (0111 1110).255.255.254  --> 十进制: `126.255.255.254/8`
>
>     - 最大网络数: **2^7^ -2 =126**; 每个子网内最大主机数: **2^24^ -2**
>
>         >   - **0.0.0.0/8 ~ 0.255.255.255/8** 为保留地址
>         >   - **127.0.0.0/8 ~ 127.255.255.255/8**, designated for [loopback](https://en.wikipedia.org/wiki/Loopback) and are used to test the ‘network stack(OSI Model, TCP/IP Model)’ of the local device.
>         >       - 127.0.0.1 等效于**localhost**或**本机IP**。 一般用于测试使用。
>         >       - `ping 127.0.0.1`来测试本机TCP/IP是否正常。
>         >       - <http://127.0.0.1:8080> 等效 <http://localhost:8080>
>
> - **B类 IP/16**(*B类IP地址的二进制位必须是10开头: 128~191*):
>
>     - 起始: (1000 0000).(0000 0000).0.1  --> 十进制:`128.0.0.1/16`
>
>     - 终止: (1011 1111).(1111 1111).255.254  --> 十进制: `191.255.255.254/16`
>
>     - 最大网络数: **2^14^**; 每个子网内最大主机数: **2^16^ -2**= 65536 - 2 =65534
>
> 
>
> - **C类 IP/24**(*C类IP地址的二进制位必须是110开头: 192~223*):
>
>     - 起始: (1100 0000).(0000 0000).(0000 0000).1  --> 十进制: `192.0.0.1/24`
>
>     - 终止: (1101 1111).(1111 1111).(1111 1111).254  -> `223.255.255.254/24`
>
>     - 最大网络数: **2^21^**; 每个子网内最大主机数: **2^8^ -2 = 254**
>
> 
>
> - D类 IP(*D类IP地址的二进制位必须是1110开头*): 作为==Multicast Addresses 组播地址==
>
>     - 起始: (1110 0000).0.0.1 --> 十进制: 224.0.0.1
>
>     - 终止: (1110 1111).255.255.254 --> 十进制: 239.255.255.254
>
> 
>
> - E类 IP(*E类IP地址的二进制位必须是1111开头*): 作为研究保留 ==Experimental purposes== 
>
>     - 起始: (1111 0000).0.0.1  --> 十进制: 240.0.0.1
>     - 终止: (1111 1111).255.255.254  -> 十进制: 255.255.255.254
>
> > “Host Portion”为全0和全1的IP地址不能指派给Host:
> >
> > -   主机号全0表示 Network Address;
> > -   主机号全1为 Broadcast Address. **Note:** *Any IP Broadcast Address is related to Layer 2 Broadcast Address(FFFF.FFFF.FFFF).*
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325902.png" alt="image-20230321004053124" style="zoom:57%;" />
>
> 
>
> ##### **RFC1918** `私有IP范围`
>
> **RFC1918** refers to a set of guidelines that define **private IP address ranges** that can be used for internal networks in private organizations. These IP addresses are not routable on the public internet and are reserved for use within private networks.
>
> The three private IP address ranges defined in RFC1918 are:
>
> - A类 IP: 10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
> - B类 IP: 172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
> - C类 IP: 192.168.0.0/16 (192.168.0.0 - 192.168.255.255)
>
> 
>
> ##### 其他特殊IP
>
> - 169.254.0.0/16: 在 Windows 系统上在DCHP无法分配IP地址时, 会自动生成这个链路本地地址;
> - 192.0.2.0/24: 保留地址, Test-Net地址;
> - 127.0.0.1: 保留用于环回测试。表示当前节点，让节点能够给自己发送测试分组，而不会生成网络流量;
> - 所有主机位都为0时，得到的是`网络地址`;
> - 所有主机位都为1 时，得到的是`广播地址`;

### IPv4 地址类型

#### Broadcast

> -   Broadcast messages are delivered to all devices on the local network. 广播消息是发送给广播域中所有主机的，其目标地址的主机位都为1。
>
> - 对于网络地址172.16.0.0 255.255.0.0 ，其广播地址为172.16.255.255 ---- 所有主机位都为1 。
>
> - 广播也可以是发送给所有网络中的所有主机的，例如255.255.255.255。
>
>     >   对应于第二层广播: 第2层广播也叫硬件广播，它们只在当前LAN内传输，而不会穿越LAN边界(路由器)。典型的硬件地址长6B (48位)，如45:AC:24:E3:60:A5 。使用二进制表示时，该广播地址全为1，而使用十六进制表示时全为F，即FF:FF:FF:FF:FF:FF 。

#### Unicast

> 单播地址是分配给网络接口卡的IP地址，在分组中用作目标地址，换句话说，它将分组传输到特定IP的主机。
>
> ==DHCP 客户端请求很好地说明了单播的工作原理==:
>
> 1. LAN中的某主机发送广播(其第2层目标地址为FF:FF:FF:FF:FF:FF，而第3层目标地址为255.255.255.255 )，在LAN中寻找DHCP服务器。
> 2. 路由器知道这是发送给DHCP服务器的广播，因为其目标端口号为67 (BootP 服务器)，因此会将该请求转发到另一个LAN中的DHCP服务器。因此，如果DHCP服务器的IP地址为172.16.10.1 ，路由器将修改该广播，将其目标地址改为172.16.10.1。为让路由器提供这种服务，你需要使用命令`ip helper-address`配置接口一一这不是默认启用的服务。

#### Multi-cast

> - Multicast messages are delivered only to devices that have joined that specific multicast group. 组播支持点到多点通信
>
> - 组播的关键点在于，它让多个接收方能够接收消息，却不会将消息传递给广播域中的所有主机。
>
> - 组播这样工作: 将消息或数据发送给IP组播地址，路由器将分组的副本从每个这样的接口转发出去(这不同于广播，路由器不转发广播)，给订阅了该组播的主机。
>
>     >   从理论上说，指的是主机将收到发送给224.0.0.10 的组播分组(EIGRP 分组，只有运行EIGRP协议的路由器才会读取它)。广播型LAN (以太网是一种广播型多路访问LAN 技术)中的所有主机都将接收这种帧，读取其目标地址，然后马上丢弃除非它是组播组的成员。这节省了PC的处理周期，但没有节省LAN带宽。如果不小心实现，组播有时会导致严重的LAN 拥塞。

### Subnet Mask

>**Subnet mask**, 又称为 **Netmask**, 由连续的1和连续0两部分组成, 32bits, 可以将某个网络的网络地址表征为 **Network Portion** 和 **Host Portion** 两部分.
>
>##### 子网掩码的作用
>
>- 子网掩码用于将IP地址划分为 **Network portion **和 **Host Portion** 两部分; IP地址必须结合子网掩码才具有意义;
>- 子网掩码只要是**连续的二进制"1"**+**连续的二进制"0"**,就是合理的子网掩码;
>- 与子网掩码中二进制"1"对应的IP地址中的地址位,代表**网络号**位; 与子网掩码中二进制"0"对应的IP地址中的地址位,代表**主机号**位;
>
>
>
>##### 标准子网掩码:
>
>- A类子网: 255.0.0.0      --> IP地址/8
>- B类子网: 255.255.0.0    --> IP地址/16
>- C类子网: 255.255.255.0  --> IP地址/24
>
><img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325339.png" alt="image-20210613142114029" style="zoom: 30%;" />
>
>
>
>##### FLSM(Fixed-Length Subnet Masks):
>
>###### 定长子网掩码:
>
>- A类私网: `10.0.0.0` ~ `10.255.255.255`      --> IP地址/8~30
>- B类私网: `172.16.0.0` ~ `172.31.255.255`    --> IP地址/16~30
>- C类私网: `192.168.0.0` ~ `192.168.255.255`  --> IP地址/24~30
>
>
>
>##### VLSM(Variable-Length Subnet Masks)
>
>###### 变长子网掩码:
>
>- A类私网: `10.0.0.0` ~ `10.255.255.255`      --> IP地址/8~30
>- B类私网: `172.16.0.0` ~ `172.31.255.255`    --> IP地址/12~30
>- C类私网: `192.168.0.0` ~ `192.168.255.255`  --> IP地址/16~30
>
>
>
>###### 划分方法:
>
>- **网段地址**: 对应IP地址的**Host Portion**位都是0; 计算方法:把IP地址与子网掩码进行`按位逻辑与`的运算,得到的IP地址就是网段地址;
>- **广播地址**: 对应IP地址的**Host Portion**位都是1; 计算方法: 子网掩码中二进制"0"的部分对应于IP地址中的位全部设为"1",得到的IP地址就是广播地址;
>- **可用的主机地址个数:** 若子网掩码中的**Host Portion**的位数为n,则为 2^n^ -2(网络本身和广播地址各占1个IP地址);
>- **子网个数**: 此概念对应于A, B, C类子网的划分, 子网掩码中**Network Portion**(A(*有效位数-8*), B(*有效位数-12*), C类(*有效位数-16*))的二进制"1"的个数为m,则为 2^m^;

> `ip subnet-zero`: 这个命令让你能够在网络设计中使用第一个子网和最后一个子网。例如， C 类子网掩码 255.255.255.192 提供了子网64 和128 (这将在本章后面详细讨论)，但配置命令ip subnet-zero 后，将可使用子网0 、64 、128 和192。也就是说，这条命令重新划分了子网, 即让每个子网掩码提供的子网多了两个。

---

#### Examples

>   ##### Finding the following items of a particular network:
>
>   -   maximum number of hosts, 
>   -   network address, 
>   -   broadcast address, 
>   -   first usable address, 
>   -   last usable address 

##### 示例1

>172.22.141.231/26, 该IP位于哪个网段? 该网段具有多少个可用的IP地址? 广播地址是什么?
>
>解答:
>
>- `子网掩码`为26: 即网络号位为26位, 主机号位为6位, 此网段*可用的主机IP地址为 2^6 -2 = 62个*
>
>- *子网个数*: 26>24, 对应着 ==C类的子网划分==; 前3个字节段都是255, 是固定的. 有效段为D段 1100 0000, "1"的个数为 m=2,子网个数为 2^m^ = *4*
>
>- IP地址转换为二进制:  172. 22.141.1110 0111
>
>    子网掩码转换为二进制: 255.255.255.1100 0000
>
>     *网段地址*: 将`IP地址`与`子网掩码`进行按位逻辑与运算: IP地址的 A段.B段.C段(都一样).1100 0000, 转换为十进制即 *172.22.141.192*;
>
>     *广播地址*: 将IP地址的所有主机号位都设为"1": 172.22.141.(11[11 1111])即 *172.22.141.255*



##### 示例2

> <img src="https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220616171955039.png" alt="image-20220616171955039" style="zoom:40%;" />

##### 示例3

![image-20220705184347440](https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220705184347440.png)

> 示例: 网络地址= 172.16.0.0/18,
>
> - 子网掩码 255.255.192.0 (/18)
>
> - 多少个子网? 2^(18-16)^ =4 。
>
> - 每个子网多少台主机? 2^(32-18)^ - 2 = 16382
>
> - 有哪些合法的子网? 块大小为`256 - 192 = 64`，因此子网为0 、64 、128 和192。鉴于子网划分是在第三个字节中进行的，因此子网号实际上为0.0 、64.0 、128.0 和192札如下面所示。
>
> - 每个子网的广播地址是什么?
>
> - 合法的主机地址是什么?
>
>     ![image-20220706123733737](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325422.png)
>
> 问题: IP地址172.16.50.10 255.255.224.0 (/19) 属于哪个子网?该子网的广播地址是多少?
> 答案: 256 - 224 = 32 ，因此子网为0.0 、32.0 、64.0 等。所属的子网为172.16.32.0, 而其广播地址为172.16.63.255 ，因为下一个子网为64.0 。

##### 示例4

<img src="https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220706123820014.png" alt="image-20220706123820014" style="zoom:90%;" />

> 示例1: 255.255.0.0 (/16)
>
> - 多少个子网? 2^(16-8)^ = 256 。
>
> - 每个子网的主机数? 2^(32-16)^ -2 = 65534
>
> - 有哪些合法的子网? 只考虑第二个字节。256-255= 1 ，因此子网为10.0.0.0, 10.1.0.0, 10.2.0.0, 10.3.0.0, ……, 10.255.0.0 。
>
> - 每个子网的广播地址是什么?
>
> - 合法的主机地址是什么?
>
>     ![image-20220706124627464](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325958.png)
>
> 练习: 主机IP 地址: 10.1.3.65/23
>
> - 首先，如果不知道/23 对应的子网掩码，你就回答不了这个问题。它对应的子网掩码为
>         255.255.254.0。这里感兴趣的字节为第三个。块大小为`256 - 254` = 2 ，因此第三个字节的子网号为0 、2 、4 、6等。在这个问题中，主机位于子网2.0 中，而下一个子网为4.0, 因此该子网的广播地址为10.1.3 .255。`10.1.2.1`-`10.1.3.254` 是该子网中合法的主机地址范围。

##### 示例5

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325239.png" alt="image-20230321010438399" style="zoom: 25%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325614.png" alt="image-20230321010719410" style="zoom:25%;" />

### CIDR

> - Classless Inter-Domain Routing(无类别域间路由);
>
> - The IETF (Internet Engineering Task Force) introduced CIDR in 1993 to replace the ‘classful’ addressing system.
>
> - The IPv4 address classes, such as class A, B, and C? Well, CIDR throws all them away!
>
>     - With CIDR, the requirements of... 
>
>         Class A = /8 
>
>         Class B= /16 
>
>         Class C = /24 
>
>         ..were **removed**. 
>
>     - This allowed larger networks to be split into smaller networks, allowing greater efficiency. 
>
>     - These smaller networks are called ‘**subnetworks**’ or ‘**subnets**';
>
> ##### Point-to-Point Network:
>
> ###### CIDR(/30)
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325959.png" alt="image-20230321005233528" style="zoom: 25%;" />
>
> ###### Better Approach: CIDR(/31)
>
> A dedicated connection like this between two routers, there is actually no need for a network address or a broadcast address. So, we can break the rules in this case and assign the only two addresses in this network to our routers.
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325766.png" alt="image-20230321005512386" style="zoom: 25%;" />
>
> >   Note that, if you try this configuration on a Cisco router, you’ll get a warning like this, reminding you to make sure that this is a point-to-point link, but it is a totally valid configuration.
> >
> >   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303210057372.png" alt="image-20230321005759169" style="zoom: 28%;" />



### VLSM

> - classful Routing: 所有的主机和路由器接口都使用相同的子网掩码;
>
>     >   classful addressing is important to understand, but in modern networks the concept is no longer used.
>
>     ![image-20220706133925715](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325100.png)
>
> - 如果要提高该网络地址的使用效率, 我们必须给每个路由器接口分配不同的子网掩码, 即`VLSM(变长子网掩码)`;
>
>     ![image-20220706133935771](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202209221436834.png)
>
>     - 每个路由器接口上可使用长度不同的子网掩码。如果在WAN链路上使用/30. 并在各个LAN 上分别使用/27 、/28 和/29. 则WAN 链路将有两个主机地址，而各个LAN分别有30 、14和6个主机地址，这极大地提高了IP地址的利用率, 尤其是 WAN IP地址.
>
>     - 通过在网络特定的区域使用连续的地址块，你可轻松地对网络进行汇总，从而最大限度地减少路由选择协议通舍的路由更新。若只需在大楼之间通告一条汇总路由就能达到相同效果，可以大大地提高效率.

#### VLSM-Steps:

>   1.   the **largest subnet** at the start of the address space;
>   2.   Assign the **second-largest subnet** after it;
>   3.   Repeat the process until all subnets have been assigned

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325325.png" alt="image-20230321015336865" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303210202244.png" alt="image-20230321020236001" style="zoom:33%;" />

#### Lab 练习

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325170.png" alt="image-20230321125547203" style="zoom: 90%;" />

>   **参考答案:**
>
>   ###### PC2
>
>   ![image-20230321130010910](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303211300033.png)
>
>   ###### PC1
>
>   ![image-20230321130045202](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325507.png)
>
>   ###### R1 Running-config
>
>   ```sh
>   interface GigabitEthernet0/0
>   description # to PC1 #
>   ip address 192.168.5.190 255.255.255.192
>   duplex auto
>   speed auto
>   !
>   interface GigabitEthernet0/1
>   description # to PC2 #
>   ip address 192.168.5.126 255.255.255.128
>   duplex auto
>   speed auto
>   !
>   interface GigabitEthernet0/2
>   no ip address
>   duplex auto
>   speed auto
>   shutdown
>   !
>   interface GigabitEthernet0/0/0
>   description # To R2 #
>   ip address 192.168.5.253 255.255.255.252
>   
>   ip classless
>   ip route 192.168.5.192 255.255.255.224 192.168.5.254 
>   ip route 192.168.5.224 255.255.255.240 192.168.5.254 
>   ```
>
>   ###### R2:
>
>   ```sh
>   interface GigabitEthernet0/0
>   description # to PC3 #
>   ip address 192.168.5.222 255.255.255.224
>   duplex auto
>   speed auto
>   !
>   interface GigabitEthernet0/1
>   description # to PC4 #
>   ip address 192.168.5.238 255.255.255.240
>   duplex auto
>   speed auto
>   !
>   interface GigabitEthernet0/2
>   no ip address
>   duplex auto
>   speed auto
>   shutdown
>   !
>   interface GigabitEthernet0/0/0
>   description # To R1 #
>   ip address 192.168.5.254 255.255.255.252
>   
>   ip classless
>   ip route 192.168.5.0 255.255.255.128 192.168.5.253 
>   ip route 192.168.5.128 255.255.255.192 192.168.5.253
>   ```
>
>   ###### PC3
>
>   ![image-20230321130252045](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325737.png)
>
>   ###### PC4
>
>   ![image-20230321130326521](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325888.png)

#### Additional Practice

-   <http:/www.subnettingquestions.com/>
-   <http://subnetting.org/>
-   <https://subnettingpractice.com/> 



### 路由汇总

路由汇总也叫起网化(supernetting)，它以最高效的方式提供路由更新，这是通过在一个通告中通告众多路由，而不是分别通告它们来实现的。这节省了大量带宽，并最大限度地降低了路由嚣的处理负担。通过使用成块的地址(别忘了，前面列出的块大小适用于各种网络)，我们可配置汇总路由，让网络的性能得到极大改善。

> - 汇总也叫路由聚合，让路由选择协议能够用一个地址通告众多网络，旨在缩小路由器中路由选择表的规模，以节省内存，并缩短E 对路由选择表进行分析以找出前往远程网络的路径所需的时间。
>
>     ![image-20220706141409719](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325111.png)

> C类的CIDR
>
> ![image-20220705182931790](https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220705182931790.png)
>
> 路由聚合示例: B类
>
> <img src="https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220616171336269.png" alt="image-20220616171336269" style="zoom:50%;" />

### Configure IP address

```sh
Router> enable
Router# show ip interface brief   # confirm the status of each interface on the router
Router# configure terminal

Router(config)# interface gigabitethernet 0/0
Router(config)# int g0/0   # 简写方法

Router(config-if)# ip address 10.255.255.254 255.0.0.0
Router(config-if)# no shutdown    # enable the interface of router
Router(config-if)# description # connected to SW1

Router# show interfaces g0/0

Router# show interfaces description
```

>   ==Status==: indicate the Layer 1 status:
>
>   -   **administratively down**: Interface has been disabled with the ‘shutdown’ command. 
>       -   This is the default Status of Cisco router interfaces.
>
>       -   Cisco switch interfaces are **NOT** administratively down by default.
>
>   -   **up**: there is another device connected to the port.
>
>   ==Protocol==: indicate the Layer 2 status:
>
>   -   down: 
>   -   up: for example is Ethernet functioning properly between this device and the device it's connected to.

### 排除 IP编址故障

> ==思科推荐的故障排除步骤==:
>
> 1. 打开命令提示符窗口，并`ping 127.0.0.1`。这是诊断(环回)地址，如果ping 操作成功，则说明IP栈初始化了。如果失败，说明IP栈出现了故障，你需要在主机上重新安装TCP/IP。
> 2. 在命令提示符窗口中， `ping 当前主机的IP地址`。如果成功，则说明网络接口卡(NIC) 正常; 如果失败，则说明NIC出现了故障。这一步成功并不意味着电缆被插入了NIC，而只意味着主机的IP协议栈能够通过LAN驱动程序与NIC通信。
> 3. 在命令提示符窗口中， `ping 默认网关(路由器)`。如果成功，说明NIC连接到了网络，能够与本地网络通信。如果失败，则说明本地物理网络出现了故障，该故障可能位于NIC到路由器之间的任何地方。
> 4. 如果第(1)步至第(3)步都成功了，请尝试`ping 远程服务器`。如果成功，你便可确定本地主机和远程服务器能够进行IP通信，且远程物理网络运行正常。
> 5. 如果第(1)步至第(4)步成功了，但用户仍不能与服务器通信，则可能存在某种名称解析问题，需要检查`域名系统(DNS)`设置。如果ping 远程服务器时失败，你便可确定存在某种远程物理网络问题，需要对服务器执行第(1)步~第(3)步操作，直到找出故障根源。

> ==基本命令==:
>
> - `ping`: 使用`ICMP请求`和`应答`进行测试，检查网络中节点的IP栈是否已被初始化并处于活动状态。If the ping is successful, that means there is **two-way reachability**.
> - `traceroute` 使用`TTL超时`和`ICMP错误消息`，显示前往某个网络目的地时经历的路径上的所有路由器。该命令不能在windows系统中使用。
> - `show ip arp` 功能与arp -a 相同，但用于在思科路由器中显示ARP表;
>
> 
>
> - `ipconfig /all` 只能在命令提示符窗口中使用，显示PC 的网络配置。
> - `tracert` 功能与traceroute 相同，是一个Microsoft Windows 命令，在思科路由器上不管用。
> - `arp -a` 在WindowsPC 中显示IP地址到MAC地址的映射。

> ==其他命令==:
>
> - `debug`: 只可在思科IOS 特权模式下运行的、用于故障排除的命令。它常用于显示各种路由器操作的信息以及由路由器产生或接收到的与流量相关的信息，此外还包括出错信息。此命令会影响设备处理互联网络中分组的能力, `debug all`的影响会非常严重. 如果路由器的CPU使用率已经达到了50%或更高，那么再使用debug all 命令就是一个十分不明智的举动，除非你真的想看到路由器是如何崩溃的!
>
>     ```sh
>     Corp#debug ?
>         aaa AAA Authentication , Author咽ization and Accounting
>         access-expresslon  Boolean access express;on
>         adjacency  adjacency
>         all    Enable all debugging
>         [output cut]
>     Corp#debug ip rip
>         RIP protocol debugging is on
>     Corp#
>         1w4d: RIP: sending v2 update to 224.0.0.9 via SerialO/O (192.168.12.1)
>         1w4d: RIP: build update entr寸es
>         1w4d: 10.10.10.0/24 via 0.0.0.0 , metr;c 2 , tag 0
>         1w4d: 171.16.125.0/24 via 0.0.0.0 , metric 3, tag 0
>         1w4d: 172.16.12.0/24 via 0.0.0.0 , metr;c 1 , tag 0
>         1w4d: 172.16.125.0/24 via 0.0.0.0 , metric 3, tag 0
>         1w4d: RIP: sending v2 update to 224.0.0.9 via SerialO/2 (172.16.12.1)
>         1w4d: RIP: bu;ld update entr寸es
>         1w4d: 192.168.12.0/24 v;a 0.0.0.0 , metr;c 1 , tag 0
>         1w4d: 192.168.22.0/24 v;a 0.0.0.0 , metr寸c 2 , tag 0
>         1w4d: RIP: received v2 update from 192.168.12.2 on SerialO/O
>         1w4d: 192.168.22.0/24 via 0.0.0.0 in 1 hops
>     Corp#undebug all 
>     ```
>
> - 命令``show processes` (或show processes CpU) 用于确定指定路由器CPU利用率的工具。此外，这一命令还提供正在运行进程的列表，以及进程ID、优先权、调度程序测试(状态)、使用CPU的时间、调用次数等数据.
>
>     ```sh
>     Corp#sh processes
>         CPU utilization for five seconds: 2%/0%; one minute: 0%; five minutes: 0%
>         PID QTy PC Runtime (ms) Invoked u5ecs 5tacks TTY Process
>         1 Cwe 8034470。1 o 5804/6000 o Chunk Manager
>         2 Csp 80369A88 4 1856 2 2616/3000 0 Load Meter
>         3 M* 。112 14 800010656/12000 0 Exec
>         5 Lst 8034FD9C 268246 52101 5148 5768/6000 o Check heaps
>         6 Cwe 80355E5ζ20 3 6666 5704/6000 o Pool Manager
>         7 Mst 802AC3C4 。2 o 5580/6000 o Timers
>         [output cut]
>     ```
>

### How are IPv4 addresses assigned?

>   -   IPv4 address assignments are controlled by IANA(Internet Assigned Numbers Authority).
>   -   IANA distributes IPv4 address space to various RIRs(Regional Internet Registries), which then assign them to companies that need them. 
>       -   For example, an Internet service provider would ask its local RIR to assign it IP addresses which can then be used by its customers.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031647242.png" alt="image-20230403164714993" style="zoom:33%;" />

---

>   ###### 关于数的进制:
>
>   -   Binary / Base 2 / 0b: 二进制, 
>   -   Decimal / Base 10 / 0d: 十进制
>   -   Hexadecimal / Base 16 / 0x: 十六进制, 
>       -   each hexadecimal digit contains **4 bits binary**; 
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031618116.png" alt="image-20230403161828875" style="zoom:33%;" />



---



## IPv6 Addressing

>   ##### Why IPv6?
>
>   -   The main reason is that there simply aren’t enough IPv4 address available! There are 4,294,967,296 (2^32^) IPv4 addresses available. 
>   -   **VLSM**, **private IPv4 addresses**, and **NAT** have been used to conserve the use of IPv4 address space. Those are short-term solutions.  
>   -   The long-term solution is **IPV6**.

### 介绍

![image-20220630150318255](https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/202209092306230.png)

> - 长度为 128 bits（**32 hexadecimal characters**, **16 Bytes**）, 或者 8个 Hextet*(16 bit)*(*4个十六进制数 为 1个 Hextet(2 Bytes)*) 。基本体系结构的网络部分为 64 位，主机部分为 64 位。通常，IPv6 地址（或其部分）的主机部分将派生自 MAC 地址或其他接口标识。
>
> - IPv6地址总数量: 2^128^ = 3.4 * 10^38^ (*可以标记地球上每一粒沙子!*)
>
> - 根据子网前缀，IPv6 的体系结构比 IPv4 的体系结构更复杂。IPv6 地址的数目比 IPv4 地址的数目大 10^28^倍。
>
> - IPv6 地址的文本格式为 `xxxx : xxxx : xxxx : xxxx : xxxx : xxxx : xxxx : xxxx`，一共8个quartets, 也即32个十六进制数。
>
> - IPv6可以内嵌IPv4, 例如，::ffff:10.120.78.40 表示 IPv4 映射的 IPv6 地址。IPv4 占据 xxxx:xxxx,, 即2个Hextet, 也即8个Hexadecimal。
>
> - 使用Web浏览器连接到IPv6设备的HITP连接时，必须将IPv6地址用方括号括起。为什么呢?因为冒号已被浏览器用来指定端口号。如果不用方括号将地址括起，浏览器将无法识别地址。
>
>     ![image-20220630150459050](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325729.png)
>
> - IPv4 环回地址为`127.0.0.1`.而IPv6 环回地址为`::1`; 
>
> -   IPv6 addresses use the `/` notation to indicate the prefix length, even when configuring the address in the Cisco IOS CLI. This `/64`, for example, means the first half of the address would be the network portion, and the second half would be the host portion.

#### Shorting(abbreviating) IPv6 addresses:

>   1.   Leading 0s can be removed.
>
>   <img src="https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220623135337200.png" alt="image-20220623135337200" style="zoom:80%;" />
>
>   2.   Consecutive quartets of all 0s can be replaced with a double colon `::`. **But you can only use the double colon to shorten an IPv6 address once!** 
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325410.png" alt="image-20220623135426137" style="zoom: 67%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031718189.png" alt="image-20230403171812088" style="zoom:33%;" />
>

###### Quiz

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031806292.png" alt="image-20230403180653072" style="zoom:33%;" />

<details>
    <summary>Correct Answer</summary>
    <p>
    <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031724263.png" alt="image-20230403172457007" style="zoom:33%;" />
    </p>
</details>

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031802159.png" alt="image-20230403180231969" style="zoom:33%;" />

<details>
    <summary>Correct Answer</summary>
    <p><img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031806730.png" alt="image-20230403180603500" style="zoom:33%;" /></p>
</details>



#### Finding the IPv6 prefix

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031748987.png" alt="image-20230403174852711" style="zoom: 28%;" />

###### Quiz:

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031750429.png" alt="image-20230403175021215" style="zoom:33%;" />



<details>
    <summary>Correct Answer</summary>
    <p>
    <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304031752588.png" alt="image-20230403175252342" style="zoom: 33%;" />
    </p>
</details>


>   ###### RFC 5952
>
>   (stands for **Request for Comments**, is a publication from the ISOC, Internet Society, and associated organizations like the IETF, Internet Engineering Task Force, and these RFCs are the official documents of Internet specifications, protocols, procedures, etc.)
>
>   -   RFC 5952 is ‘A Recommendation for IPv6 Address Text Representation’ ; Before this RFC, IPv6 address representation was more flexible;
>       -   You could remove leading 0s, or leave them;
>       -   You could replace all-0 quartets with ::, or leave them 
>       -   You could use upper-case 0xA,B,C,D,E,F, or lower-case 0xa,b,c,d,e,f
>   -   RFC 5952 suggests standardizing IPv6 address representation:
>       -   Leading 0s MUST be removed;
>       -   `::` MUST be used to shorten the longest string of all-O quartets.
>       -   If there are two equal-length choices for the `::`, use `::` to shorten the one on the left.
>       -   Hexadecimal characters ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, and ‘f MUST be written using lower-case, NOT upper-case AB c D E E



### IPv6的分类

>   -   Typically, an enterprise requesting IPv6 addresses from their ISP will receive a `/48` block.
>   -   Typically IPv6 subnets use a `/64` **prefix length**.
>   -   So, the enterprise received a /48 block, but the usual prefix length is /64. This means that an enterprise has **16 bits to use to make subnets**.
>   -   And the remaining 64 bits can be used for hosts.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325626.png" alt="image-20220623135655198" style="zoom:60%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325019.png" alt="image-20220623095058115" style="zoom:67%;" />

> - ==Global Unicast==地址:
>     - Originally defined as `2000::/3`(from `2000::` to `3FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF`); **Now all addresses which aren’t reserved for other purposes are global unicast addresses.**
>
>     - public addresses which can be used over the Internet.
>
>     - must register to use global unicast addresses. Because they are public addresses, it is expected that they are globally unique. 
>
>     - three sections of a global unicast address:
>         - the global routing prefix: 48 bits;
>
>         - the subnet identifier: 16 bits, means 65535 subnets;
>
>         - the interface identifier: 48 bits;
>
> - ==Unique Local==: 
>     - Uses the address block `FC00::/7` (from `FC00::` to `FDFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF`); however a later update requires that the 8th bit be set to 1, **so really all unique local addresses will begin with `FD`**.
>     - private addresses which cannot be used over the Internet(*like private IPv4 addresses*). 
>         - do not need to register to use them. They can be used freely within internal networks and don’t need to be globally unique, but you should still try to make the addresses unique.
>
>     - Can't be routed over the Internet, your ISP will simply **drop packets** destined for unique local addresses.
>
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080845155.png" alt="image-20230408084526914" style="zoom:28%;" />
>
> >   ###### Why should Global ID be randomly generated and not just use something simple like all 0s?
> >
> >   -   The global ID should be unique so that addresses don’t overlap when companies merge. If all companies use the simple global ID of all 0s, when two companies merge and connect their networks they might have the same subnet in different parts of the network, which can cause a lot of problems.
> >   -   By randomly generating this global ID, the chances of having duplicate subnets are very low. 
> >   -   So, even though these unique local addresses don’t have to be globally unique, it’s still a good idea to randomly generate the global ID and try to make it globally unique.
>
> - ==Link Local==: 类似于Windows自动配置的IP地址169.254.x.x;
>     - Uses the address block `FE80::/10` (`FE80::` to `FEBF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF`); However, the standard states that **the 54 bits after `FE80/10` should be all 0**, so you won’t see link local addresses beginning with FE9, FEA, or FEB. **Only FE8**.
>
>     - automatically generated **using EUI-64 rules** on IPv6-enabled interfaces; you can use the command `Router(config-if)#ipv6 enable` to enable IPv6 on an interface without actually configuring an IPv6 address on it. It will then automatically generate a link-local IPv6 address, and that will be the only IPv6 address on the interface.
>
>     - Link local means that these addresses are used for communication within a single link, a single subnet. Routers will not route packets with a link-local destination IPv6 address, they will not forward the packets between subnets.
>
>     - **must specify the exit-interface when using the Link-local address as ipv6 next-hop**;
>
>     - **Common Uses of Link-Local addresses**:
>         - routing protocol peerings(OSPFv3(used for IPv6) uses link-local addresses for neighbor adjacencies, sending LSAs,etc.)
>
>         - used as the next-hop address for static routes.
>
>         - Neighbor Discovery Protocol (NDP, IPv6’s replacement for ARP) uses link-local addresses to function
>
> - ==Multicast==: 
>     - IPv6 uses range `FF00::/8` for multicast. (`FF00::` to `FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF`); 与IPv4 中一样，将组播地址用作目标地址的分组将被传输到该地址标识的所有接口。这种地址也被称为`一对多地址`;
>
>     - IPv6 doesn’t use broadcast (there is no ‘Broadcast Address’ in IPv6!) Basically, `FF0::1` functions like a broadcast, since it’s destined for **all hosts** like a broadcast. 
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080913515.png" alt="image-20230408091310204" style="zoom: 29%;" />
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080927473.png" alt="image-20230408092718250" style="zoom:33%;" />
>
> >   ###### Multicast address scopes:
> >
> >   -   IPv6 defines multiple multicast ‘scopes’ which indicate how far the multicast packet should be forwarded. 
> >   -   For example, the addresses in the previous slide all use the ‘link-local’ scope (FF02), which stays in the local subnet.
> >   -   **IPv6 multicast scopes**:
> >       -   **Interface-local scope (FF01, aka. ‘node-local’)**: The packet doesn’t leave the local device. Can be used to send traffic to a service within the local device, but the router won’t actually send traffic out of a physical interface.
> >       -   **Link-local scope (FF02)**: The packet remains in the local subnet. Routers will not route the packet between subnets.
> >       -   **Site-local scope (FF05)**: The packet can be forwarded by routers. Should be limited to a single physical location (not forwarded over a WAN). it’s up to the network engineers to configure the boundaries of the scope.
> >       -   **Organization-local scope (FF88)**: Wider in scope than site-local (an entire company/organization). it’s up to the network engineers to configure the boundaries of the scope.
> >       -   **Global scope (FF0E)**: No boundaries. Possible to be routed over the Internet.
> >
> >   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080925726.png" alt="image-20230408092552446" style="zoom:33%;" />
>
> - ==Anycast==: `2000::/3`;
>     - a new feature of IPv6; Anycast messaging is ‘one-to-one-of-many’. There are multiple possible destinations, but the traffic is only sent to one. 
>         - Multiple routers are configured with the same IPv6 address. They use a routing protocol to advertise the address;
>
>         - when hosts send packets to that destination address, other routers will forward it to the nearest router configured with that IP address(‘Nearest’ refers to the smallest routing protocol metric).
>
>     - there is no specified range for anycast addresses. Use a regular unicast address, for example a **Global Unicast** or **Unique Local** address and specify it as an **Anycast** address.
>
>
> <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080933736.png" alt="image-20230408093354497" style="zoom:33%;" />
>
>
> > ==What is the difference between IPv6 unicast and anycast addressing?==
> >
> > An individual IPv6 unicast address is supported on a single interface on one node but an IPv6 anycast address is assigned to a group of interfaces on multiple nodes.

>##### 特殊的IPv6地址
>
>- `::` 相当于IPv4 地址`0.0.0.0`;
>    - can be used when a device doesn’t know its IPv6 address yet. 
>    - IPv6 default routes are configured to `::/0`
>- `::1` Loopback Address, 
>    - used to test the protocol stack on the local device.
>    - Messages sent to this address are processed within the local device, but not sent to other devices.
>    - 相当于IPv4 地址`127.0.0.0/8`; Instead of wasting a huge block of addresses in IPv4 for loopbacks, IPv6 uses just a single address, which is much more efficient.
>- `2001:db8::/32` This address is commonly used in documentation and examples, and it is not intended to be used in a real network. 
>- `2002::/16` 保留供**6to4隧道技术**使用。6to4隧道技术是一种从IPv4迁移到IPv6的方法，让IPv6分组能够通过IPv4网络进行传输，而无需配置显式的隧道;

> ##### IPv6 的优势
>
> - 海量地址: IPv6的地址长度为128bit, 一共 3.4 x 10^38^ 个地址;
> - 简化的报文头: IPv6 分组报头包含的字段减少了一半，且所有字段都与64位边界对齐，这极大地提高了效率一一相比于IPv4. 查找速度要快得多;
> - 层次化的编址结构: 新增的长度让地址空间可包含更多的层次，从而提供了更灵活的编址架构; 提高了路由选择的效率和可扩展性，因为可以更有效地聚合地址。
> - 即插即用: IPv6支持无状态地址自动配置(SLLAC), 终端接入更加简单;
> - 安全性提高: IPsec机制, 真实的源地址认证保证了端到端安全; 避免IPv4中的NAT破坏端到端通信的完整性;
> - 增强的Qos特性: 额外定义了流标签字段, 可为应用程序和终端所用, 针对特殊的服务和数据流分配特定的资源
> - IPv6 还允许主机和网络有多个地址，这对亟须改善可用性的企业来说显得尤其重要。
> - IPv6 还更广泛地使用了组播通信(一台设备向很多主机或一组选定的主机发送数据);
> - IPv6 还支持另外两种通信:单播和任意播，其中单播与IPv4 中相同，而任意播是新增的。任意播可将同一个地址分配给多台设备，而向该地址发送数据流时，它会被路由到共享该地址的最近主机。这仅仅是开始，在15 .3 .2 节，我们会更详细地介绍各种类型的通信。



### NDP

#### Solicited-Node Multicast Address

>   -   An IPv6 solicited-node multicast address is calculated from a unicast address.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081713546.png" alt="image-20230408171355352" style="zoom:33%;" />
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081715443.png" alt="image-20230408171524242" style="zoom:38%;" />

#### Neighbor Discovery Protocol

>   -   is a protocol used with IPv6.
>   -   It has various functions, and one of those functions is to *replace ARP*, which is no longer used in IPv6.

##### Function 1: replace ARP(in IPv4)

>   -   The ARP-like function of NDP uses **ICMPv6** and **solicited-node multicast addresses** to learn the MAC address of other hosts. 
>       -   (ARP in IPv4 uses **broadcast** messages for the ARP requests.)
>       -   Solicited-node multicast messages are much more efficient, being addressed to a specific host, unlike a broadcast which is for all hosts.
>   -   In the process, two message types are used:
>       -   **Neighbor Solicitation** message(the NDP equivalent of an ARP request) = **ICMPv6 Type 135**;
>       -   **Neighbor Advertisement** message(the NDP equivalent of an ARP reply) = **ICMPv6 Type 136**;

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081732565.png" alt="image-20230408173259215" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081733929.png" alt="image-20230408173358606" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081735853.png" alt="image-20230408173520561" style="zoom:33%;" />

##### Function 2:

>   -   Another function of NDP **allows hosts to automatically discover routers on the local network**.
>   -   two messages are used for this process(**allow a device to learn the network prefix for SLAAC**):
>       -   **Router Solicitation**, which is *ICMPv6 type 133*; 
>           -   Sent to multicast address `FF02::2`, the all routers address;
>           -   asks routers on the local link(the local network) to identify themselves;
>           -   This message is sent *when an interface is enabled*, or *when the host is connected to the network*.
>       -   **Router Advertisement**, *ICMPv6 type 134*;
>           -   sent to multicast address `FF02::1`, the all nodes address;
>           -   Using this message, *the router announces its presence* and *provides some other information about the link, the local network*.
>           -   These messages are sent in response to **RS messages**. However, even if the router doesn’t receive an RS, it will send RAs **periodically**.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081741310.png" alt="image-20230408174154152" style="zoom:33%;" />

##### Function 3: SLAAC

See [Configuration of SLAAC](#Configuration of SLAAC)



##### Function 4: DAD

>   -   **Duplicate Address Detection**(DAD), which is another function of NDP, allows hosts to check if other devices on the local link are using the same IPv6 address.
>   -   Any time an IPv6-enabled interface initializes, for example via the `no shutdown` command, or an IPv6 address is configured on an interface(for example a manual IPv6 address, or a SLAAC, etc.), the device performs DAD to check if another device is using that same IPv6 address.
>   -   DAD uses two messages(that you already learned earlier):
>       -   **Neighbor Solicitation** 
>       -   **Neighbor Advertisement**
>   -   To perform DAD, the host will **send an NS** to its own IPv6 address(solicited-node multicast address). 
>       -   If it doesn’t get a reply it knows the address is unique.
>       -   However, if it does get a reply, a neighbor advertisement message, it means that another host on the network is already using the address.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081802940.png" alt="image-20230408180205785" style="zoom:33%;" />

### IPv6配置方式

#### 手动配置IPv6

> 1.   全局配置模式下, 执行 `ipv6 unicast-routing`, enables the routers to **perform IPv6 routing**;
>
>      If you don’t enable this, it’s not going to actually forward IPv6 packets.
>
> 2.   接口配置模式下:
>
>      - 可指定一个完整的128 位IPv6 全局地址:
>
>          执行 `ipv6 address 2001:db8:3c4d:1:0260:d6FF.FE73:1987/64`;
>         
>     - 也可使用eui-64 选项。eui-64 格式允许设备对其MAC地址进行转换，以生成接口ID:
>      
>         执行 `ipv6 address 2001:db8:3c4d:1::/64 eui-64`
> 
>>   若使接口只使用==链路本地地址==，可使用接口配置命令`ipv6 enable`

##### 配置固定的IPv6

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304040456447.png" alt="image-20230404045625167" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304040501916.png" alt="image-20230404050107696" style="zoom:33%;" />

>   -   Notice that the **shortened version** of the address is displayed, not all 32 hex digits;
>   -   Each of these interfaces has two IPv6 addresses, even though we only configured one. `FE80::/10` are called ‘**link-local**’ addresses, and they are automatically configured on an interface w*hen you configure an IPv6 address, when IPv6 is enabled on the interface.* 



##### EUI-64 配置

>   -   EUI stands for **Extended Unique Identifier**；‘EUI-64’ isn’t really a ‘type’ of IPv6 address, it’s a method of automatically generating an IPv6 address using a specified prefix and a MAC address.
>   -   EUI-64 allows routers to **automatically generate an IPv6 address** by *expanding their MAC address to a 64-bit interface ID*, which is then *combined with the specified IPv6 address prefix*.
>   -   the technically correct term is ‘**modified’ EUI-64**, but usually it’s just referred to as **EUI-64**.
>   -   is a method of converting a **48-bit MAC address** into a **64-bit interface identifier**， and this interface identifier can then become the ‘*host portion*’ of a /64 IPv6 address.
>
>   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080740309.png" alt="image-20230408074035076" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080745149.png" alt="image-20230408074540885" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080749673.png" alt="image-20230408074911341" style="zoom:36%;" />

###### Quiz：

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080741426.png" alt="image-20230408074157186" style="zoom:30%;" />



<details>
    <summary>Correct Answer</summary>
    <p><img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304080744662.png" alt="image-20230408074405393" style="zoom:30%;" />
    </p>
</details>



###### Why invert the 7th bit?

>   -   MAC addresses can be divided into two types:
>
>       -   **UAA**(Universally Administered Addresses): **uniquely** assigned to the device by the manufacturer;
>
>       -   **LAA** (Locally Administered Address) : Manually assigned by an admin (with the `mac-address` command on the interface) or protocol. **Doesn’t have to be globally unique**.
>
>   -   You can identify a UAA or LAA by the 7th bit of the MAC address, which is called the U/L bit(Universal/Local bit):
>       -   U/L bit set to 0 = UAA 
>       -   U/L bit set to 1 = LAA
>   -   However, in the context of IPv6 addresses and EUI-64, the meaning of the U/L bit is reversed:
>       -   U/L bit set to 0 = means that the MAC address the EUI-64 interface ID was made from was an LAA;
>       -   U/L bit set to 1 = means that the MAC address the EUI-64 interface ID was made from was an UAA;
>
>   >   Note that this doesn’t actually effect the function of the IPv6 address itself. It doesn’t mean the IPv6 address is universal or local. If you want to know the exact reasons for this inversion, do a Google search for ‘*eui-64 packetlife.net*’, there is a great explanation there.

#### SLAAC

> -   SLAAC stands for **Stateless Address Auto-configuration**
> -   SLAAC is a standard function of IPv6, Not only routers but also end hosts like PCs can do this too.
> -   自动配置是一种很有用的解决方案，让网络中的设备能够给自身分配链路本地单播地址和全局单播地址。
> -   When using SLAAC, hosts use the RS and RA messages to learn the IPv6 prefix of the local link(i.e. `2001:db8::/64`), and then automatically generate an IPv6 address.
> -   When using the `ipv6 address prefix/prefix-Length eui-64` command, you need to manually enter the prefix.
> -   However, the command for SLAAC `ipv6 address autoconfig` command, you don't need to enter the prefix. The device uses **NDP** to learn the prefix used on the **local link** via RS/RA messages. 
> -   Then the device will use **EUI-64** to generate the interface ID, *or it can be randomly generated*(depending on the device and maker).
>
> >   ###### Example:
> >
> >   -   R1 is configured with an IPv6 address, but R2 doesn’t have one yet. So, I use the command IPV6 ADDRESS AUTOCONFIG on R2’s G0/0 interface, and you can see the **global unicast address** it generated, and of course **the link-local address**, as always.
> >
> >   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081749031.png" alt="image-20230408174938837" style="zoom:43%;" />
>
> ##### 运行步骤:
>
> 1. 主机首先从路由器那里获悉前缀信息(全局前缀和子网信息): 发送一条路由器请求(Router Solicitation, RS)消息。该消息以组播方式发送给所有路由器。这实际上是一种ICMP消息，并用编号进行标识。则消息的ICMPv6类型为133.
>
> 2. 路由器使用一条路由器通告(RA) 进行应答，其中包含请求的前缀信息。RA消息也是组播分组，被发送到表示所有节点的组播地址，其ICMPv6类型为134. RA消息是定期发送的，但主机发送RS消息后，可立即得到响应
>
> 3. 主机再将自己的接口MAC地址(48bit)在中间插入额外的位FFFE, 然后用作接口ID(64bit)。
>
> 
>
> ##### 主机或接口ID(EUI-64) 的生成:
>
> - 在MAC地址的中间插入额外的位，即FFFE。
>
> - 插入后将采用改进的==eui-64 (扩展唯一标识符)==格式，它使用首字节的第7位来标识地址是本地唯一的还是全局唯一的:
>
>     - 如果这一位为1，则表示地址是全局唯一的;
>
>     - 如果为0，则表示地址是本地唯一的。
>
>         <img src="https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220623131728916.png" alt="image-20220623131728916" style="zoom:80%;" />

##### 案例

![img](https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325393.png)

We will *enable SLAAC on interface R1-e0/0* which will *receive prefix information from Router R6*.

###### Step-1 Enable IPv6 Routing on R6

```sh
R6(config)#ipv6 unicast-routing
```

###### Step-2 Enable IPv6 and Add prefix on R6

```shell
interface Ethernet0/0
no shutdown
ip address 192.168.100.10 255.255.255.0
ipv6 address 2000:1234:5678::6666:1/64
ipv6 enable
end
```

###### Step-3 Enable IPv6 Routing on R1

```sh
R1(config)#ipv6 unicast-routing
```

###### Step-4 Enable IPv6 and configure IPv6 auto-config on R1

```shell
interface Ethernet0/0
no shutdown
no ip address
ipv6 address autoconfig
ipv6 enable
end
```

###### Result

```sh
R1#sh ipv6 interface ethernet 0/0
Ethernet0/0 is up, line protocol is up
  IPv6 is enabled, link-local address is FE80::A8BB:CCFF:FE00:2000 
  No Virtual link-local address(es):
  Stateless address autoconfig enabled
  Global unicast address(es):
    2000:1234:5678:0:A8BB:CCFF:FE00:2000, subnet is 2000:1234:5678::/64 [EUI/CAL/PRE]
      valid lifetime 2591997 preferred lifetime 604797
  Joined group address(es):
    FF02::1
    FF02::2
    FF02::1:FF00:2000
  MTU is 1500 bytes
  ICMP error messages limited to one every 100 milliseconds
  ICMP redirects are enabled
  ICMP unreachables are sent
  ND DAD is enabled, number of DAD attempts: 1
  ND reachable time is 30000 milliseconds (using 30000)
  ND advertised reachable time is 0 (unspecified)
  ND advertised retransmit interval is 0 (unspecified)
  ND router advertisements are sent every 200 seconds
  ND router advertisements live for 1800 seconds
  ND advertised default router preference is Medium
  Hosts use stateless autoconfig for addresses.
```



### IPv6 Static Routing

>   -   IPv6 routing works the same as IPv4 routing.
>       1.   A packet arrives on one of the router’s interfaces, it looks up the destination IP address in its routing table, 
>       2.   and then forwards the packet according to the most specific match in the routing table;
>   -   However the two processes(IPv4 routing & IPv6 routing) are separate on the router, and the two routing tables(`show ip route` & `show ipv6 route`) are separate as well.
>   -   IPv4 routing is enabled on Cisco routers by default; However, IPv6 routing is disabled by default, and must be enabled with the `ipv6 unicast-routing` command.
>   -   If IPv6 routing is disabled, the router will be able to send and receive IPv6 traffic, but will not ‘route’ IPv6 traffic, meaning it will not forward traffic between networks. **Always make sure to use the `ipv6 unicast-routing` command.**

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304081814729.png" alt="image-20230408181438388" style="zoom:33%;" />

>   -   Just like in IPv4, a connected ‘**network route/64**’ is automatically added for each connected network;
>   -   Also, a local ‘**host route/128**’ is automatically added for each address configured on the router.
>   -   the route to `FF00::/8`, that’s the IPv6 multicast range. It says ‘**via Null0**’, which is an interface that discards traffic matching that route, so this discards multicast traffic. *This route was automatically configured, but it’s beyond the scope of the CCNA.*
>   -   **Routes for link-local addresses are not added to the routing table.**

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304082126725.png" alt="image-20230408212627562" style="zoom:33%;" />

>   -   Curly brackets `{}` mean a required choice.
>   -   square brackets `[]` mean optional;

>   There is actually a name for each of these different kinds of static routes, depending on if you specify just the exit interface, just the next hop, or both. (This concept isn’t unique to IPv6, by the way, it applies to IPv4 static routes too.):
>
>   -   **Directly Attached** static route is a route where only the exit interface is specified, `ipv6 route destination/prefix-Length exit-interface`;
>
>       >   -   **In IPv6, you can’t use Directly Attached static routes if the interface is an Ethernet interface!** The command will work, but the route will not!
>       >   -   If it was a serial interface, for example, it would work!
>
>   -   **Recursive** static route: specifies only the next hop address, `ipv6 route destination/prefix-Length next-hop`; (It’s because it requires a ‘recursive’ lookup in the routing table, R1 has to check its routing table multiple times - First, it has to look up the destination; Then it has to look up the next hop to know which interface to send the traffic out of.)
>
>   -   **Fully specified** static route: Both exit interface and next hop are specified, `ipv6 route destination/prefix-Length exit-interface next-hop`; 
>
>       >   If you want to use a link-local address as a next-hop, you have to specify both **the next hop address** and **the exit interface**.
>       >
>       >   <img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304082141544.png" alt="image-20230408214145305" style="zoom:59%;" />

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202304082139314.png" alt="image-20230408213937966" style="zoom:33%;" />



### IPv6 Dynamic Routing protocols

所有IPv6路由选择协议最大的变化之一可能是，在接口配置模式下启用网络通告，而不是在路由器配置模式下使用network 命令。

#### RIPng

> - RIPng 的主要功能与RIPv2 相同。它仍是一种`距离矢量胁议`，`最大跳数为15`，并使用`水平分割`、`反向抑制(poison reverse)`等环路避免机制，但使用`UDP端口521` 而不是UDP520。
>
> - 仍使用`组播`来发送更新，但在IPv6 中，使用的目标地址为`FF02::9`。这实际上很好，因为在RIPv2中，使用的组播地址为`224.0.0.9`;
>
> - RIPv2 中，路由器在路由选择表中存储了前往每个网络的下一跳地址，但在RIPng 中，路由器存储的下一跳地址为`链路本地地址`，而不是全局地址。
>
> - 使用RIPng 时，可直接在接口上通告该路由选择协议，这将创建一个RIPng进程(而无需在路由器配置模式下启动RIPng 进程)，如下所示:
>
>     ```sh
>     Router1(config-if)#ipv6 rip 1 enable
>     ```
>
> - 但如果要进入路由器配置模式，以配置重分发等功能，也可以这样做，如下所示:
>
>     ```shell
>    Routerl(config)#ipv6 router rip 1
>    ```
> 



#### EIGRPv6

> - EIGRPv6 也是一种高级距离矢量协议，有一些链路状态协议的特征。它也使用`Hello分组`来发现邻居，使用`可靠传输协议(RTP)` 来提供可靠的通信，并使用`弥散更新算法(DUAL)` 实现无环路快速会聚。
>
> - Hello 和更新分组是以组播的方式发送的，与R1Png 一样， EIGRPv6 使用的组播地址的最后部分与原来相同:在IPv4 中，使用的组播地址为224.0.0.10 ，而在IPv6 中，使用的组播地址为FF02::A (A是10 的十六进制表示)。
>
> - 要启用EIGRPv6 ，需如下操作:
>
>     ```sh
>     Router1(config)#ipv6 router eigrp 10  # 10 自治系统(AS) 号
>     Router1(config-rtr)#no shutdown
>                                             
>     Router1(config-if)#ipv6 eigrp 10 # 进入指定接口的配置模式
>     ```

#### OSPFv3

> - 仍是一种链路状态路由选择协议，将整个互联网络或自治系统划分成区域，以形成层次结构;
>
> - 在OSPFv2中，默认情况下，路由器ID( 阻D)为最大的四地址(也可以手工指定它)，但在OSPFv3中，需要手工指定阳D 和区域ID ，它们仍是32 位的值，但不再默认使用E 地址，因为IPv6 地址长128 位。通过要求手工指定这些值，并将OSPF 分组报头中的IP 地址删除，使OSPFv3 几乎可用于任何网络层协议;
>
> - 在OSPFv3中，邻接关系和下一跳属性是使用链路本地地址指定的，它还使用组播来发送更新和确认:
>
>     - 用组播地址**FF02::5 表示OSPF路由器**，并用组播地址**FF02::6 表示OSPF指定路由器**。在OSPFv2中，与这些组播地址对应的分别是224.0.0.5和224.0.0.6 0;
>
> - 可在接口配置模式下将接口及其连接的网络加入OSPF进程:
>
>     ```shell
>     Router1(config)#ipv6 router osfp 10
>     Router1(config-rtr)#router-id 1.1.1.1
>     ```
>
> - 要配置汇总和重分发等，必须进入路由器配置模式;但配置OSPFv3 时，可不在这种模式下进行，
>         而可在接口模式下进行配置。
>         配置完接口后，将自动创建OSPF 进程。接口配置类似于下面这样:
>
>     ```shell
>     Router1(config-if)#ipv6 ospf 10 area 0.0.0.0
>     ```
>
>     因此，只需进入每个接口，并指定进程ID 和区域即可。

### IPv4 迁移到 IPv6

<img src="https://cdn.jsdelivr.net/gh/Jonas-Wolfxin/MyPicgo/img/202303310325401.png" alt="image-20220623104136985" style="zoom:87%;" />

#### dual-stack双栈技术(ISATAP)

> -   允许设备同时运行IPv4和IPv6协议栈，从而能够同时支持现有IPv4和新的IPv6。
> -   one way of transitioning your network from IPv4 to IPv6. You keep IPv4 running, add IPv6 on top, and then slowly transition to using IPv6 exclusively. 

在思科路由器上配置双栈非常容易: 只需启用IPv6路由转发并给接口配置IPv6地址即可，如下所示:

```shell
corp(config)#ipv6 unicast-routing
corp(config)#interface fastethernet 0/0
corp(config-if)#ipv6 address 2001:db8:3c4d:l::/64 eui-64
corp(config-if)#ip address 192.168.255.1 255.255.255.0
```

#### 6to4 隧道技术

> 如果要让两个IPv6网络通过IPv4网络进行通信，可选择这种策略。简单地说，隧道技术就是拦截要穿越IPv4网络的IPv6分组，并给它添加一个IPv4报头。

![image-20220701003651014](https://cdn.jsdelivr.net/gh/Wolfxin/MyPicGo/img/image-20220701003651014.png)

要创建隧道， 需要两台前面介绍过的双栈路由器，并添加一些配置， 在这些路由器之间建立一条隧道。隧道的创建非常简单，只需告诉每台路由器，隧道的起点和终点在什么地方。要在圈15-3 所示的路由器之间建立隧道，只需做如下配置:

```shell
Routerl(config)#int tunnel 0
Routerl(config-if)#ipv6 address 2001:db8:1:1::1/64
Routerl(config-if)#tunnel source 192.168.30.1
Routerl(config-if)#tunnel destination 192.168.40.1
Routerl(config-if)#tunnel mode ipv6ip

Rout er2(config)#int tunnel 0
Router2(config-if)#ipv6 address 2001:db8:2:2::1/64
Router2(config斗f)#tunnel source 192.168.40.1
Rout er2(config-if)#tunnel destination 192.168.30.1
Route r2(config-if)#tunnel mode ipv6ip
```

需要注意的一个要点是，如果穿越的IPv4网络包含NAT转换点， 前面创建的隧道将遭到破坏! 多年来，NAT 获得了重大改进，能够处理特定的协议和动态连接;如果没有这些改进，NAT可能破坏大部分连接。鉴于大多数NAT实现都没有考虑这种迁移策略，因此NAT会带来麻烦。但有一种解决这种问题的方案，被称为`Teredo`，借助它能够将通过隧道传输的数据流都放在UDP分组中。NAT不理会UDP分组，因此这些分组不会像其他协议分组那样遭到破坏。使用Teredo后，分组将伪装成UDP分组，从而逃过NAT破坏。

#### NAT-PT 转换技术

> 不同于IPv4 NAT , NAT-PT 和NAPT-PT并非用于在公有IPv6地址和私有IPv6 地址之间转换，而用于在IPv4 地址和IPv6 地址之间转换。再重申一次，仅在万不得已时才能使用它。在大多数情况下，隧道技术的效果要好得多，没有这种配置带来的麻烦和系统开销。

> 有一种迁移策略名为NAT协议转换(NAT-PT), 只有在万不得已的情况下才使用这种方法，因为它并非很好的解决方案。使用这种解决方案时， IPv4主机只能与IPv4主机通信，而IPv6主机也只能与IPv6主机通信。NAT-PT不重新封装分组，而将分组从一种IP类型转换为另一种IP类型。
>
> 与IPv4中的NAT一样，实现NAT-PT的方式有3种:
>
> - 静态NAT-PT 提供一对一的映射，将一个IPv4 地址映射到一个IP喃地址，这类似于静态NAT;
>- 动态NAT-PT，它使用一个IPv4 地址池，将一个IPv4 地址映射到一个IPv6 地址;
> - 有端口地址转换协议转换(NAPT-PT)，它提供多对一映射，将多个IPv6地址映射到同一个IPv4地址和不同的端口号。

